---
output:
  html_document:
    theme: cerulean
    highlight: tango
    code_folding: hide
    toc: yes
    toc_float: no
  pdf_document:
    number_sections: yes
geometry: margin = 1.2in
fontsize: 10pt
always_allow_html: yes
---



<div id="working-with-json" class="section level1">
<h1>Working with JSON</h1>
<pre class="r"><code>library(tidyverse)</code></pre>
<div class="alert alert-info">
<p>── Attaching packages ──────────────────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ──</p>
</div>
<div class="alert alert-info">
<p>✔ ggplot2 3.1.0 ✔ purrr 0.3.2</p>
<p>✔ tibble 2.1.1 ✔ dplyr 0.8.0.1</p>
<p>✔ tidyr 0.8.3 ✔ stringr 1.4.0</p>
<p>✔ readr 1.3.1 ✔ forcats 0.4.0</p>
</div>
<div class="alert alert-info">
<p>── Conflicts ─────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──</p>
<p>✖ dplyr::filter() masks stats::filter()</p>
<p>✖ dplyr::lag() masks stats::lag()</p>
</div>
<pre class="r"><code>library(jsonlite)</code></pre>
<div class="alert alert-info">
<p>Attaching package: ‘jsonlite’</p>
</div>
<div class="alert alert-info">
<p>The following object is masked from ‘package:purrr’:</p>
<pre><code> flatten</code></pre>
</div>
<pre class="r"><code>yelp &lt;- fromJSON(&quot;data/yelp_academic_dataset_business.json&quot;)</code></pre>
<div class="alert alert-danger">
<p><strong>Error</strong> in parse_con(txt, bigint_as_char): parse error: trailing garbage</p>
<pre><code>        true}, &quot;type&quot;: &quot;business&quot;}  {&quot;business_id&quot;: &quot;UsFtqoBl7naz8A

                  (right here) ------^</code></pre>
</div>
<p>However, when we run the above command we would actully get an error like below.</p>
<p>This is because this JSON file turned out to be something called ‘NDJSON (Newline delimited JSON)’, which means there are multiple JSON values inside this file and each of the JSON values is considered as an independent object. In this particular case, each business information makes up one single JSON value therefore there are many JSON values inside of this JSON file. This could be used often in data streaming situations where each JSON data can be separated from other parts of the file so that each JSON data can be processed without waiting for the whole document to load.</p>
<pre class="r"><code>yelp &lt;- stream_in(file(&quot;data/yelp_academic_dataset_business.json&quot;))</code></pre>
<pre><code>## 
 Found 500 records...
 Found 1000 records...
 Found 1500 records...
 Found 2000 records...
 Found 2500 records...
 Found 3000 records...
 Found 3500 records...
 Found 4000 records...
 Found 4500 records...
 Found 5000 records...
 Found 5500 records...
 Found 6000 records...
 Found 6500 records...
 Found 7000 records...
 Found 7500 records...
 Found 8000 records...
 Found 8500 records...
 Found 9000 records...
 Found 9500 records...
 Found 10000 records...
 Found 10500 records...
 Found 11000 records...
 Found 11500 records...
 Found 12000 records...
 Found 12500 records...
 Found 13000 records...
 Found 13500 records...
 Found 14000 records...
 Found 14500 records...
 Found 15000 records...
 Found 15500 records...
 Found 16000 records...
 Found 16500 records...
 Found 17000 records...
 Found 17500 records...
 Found 18000 records...
 Found 18500 records...
 Found 19000 records...
 Found 19500 records...
 Found 20000 records...
 Found 20500 records...
 Found 21000 records...
 Found 21500 records...
 Found 22000 records...
 Found 22500 records...
 Found 23000 records...
 Found 23500 records...
 Found 24000 records...
 Found 24500 records...
 Found 25000 records...
 Found 25500 records...
 Found 26000 records...
 Found 26500 records...
 Found 27000 records...
 Found 27500 records...
 Found 28000 records...
 Found 28500 records...
 Found 29000 records...
 Found 29500 records...
 Found 30000 records...
 Found 30500 records...
 Found 31000 records...
 Found 31500 records...
 Found 32000 records...
 Found 32500 records...
 Found 33000 records...
 Found 33500 records...
 Found 34000 records...
 Found 34500 records...
 Found 35000 records...
 Found 35500 records...
 Found 36000 records...
 Found 36500 records...
 Found 37000 records...
 Found 37500 records...
 Found 38000 records...
 Found 38500 records...
 Found 39000 records...
 Found 39500 records...
 Found 40000 records...
 Found 40500 records...
 Found 41000 records...
 Found 41500 records...
 Found 42000 records...
 Found 42500 records...
 Found 43000 records...
 Found 43500 records...
 Found 44000 records...
 Found 44500 records...
 Found 45000 records...
 Found 45500 records...
 Found 46000 records...
 Found 46500 records...
 Found 47000 records...
 Found 47500 records...
 Found 48000 records...
 Found 48500 records...
 Found 49000 records...
 Found 49500 records...
 Found 50000 records...
 Found 50500 records...
 Found 51000 records...
 Found 51500 records...
 Found 52000 records...
 Found 52500 records...
 Found 53000 records...
 Found 53500 records...
 Found 54000 records...
 Found 54500 records...
 Found 55000 records...
 Found 55500 records...
 Found 56000 records...
 Found 56500 records...
 Found 57000 records...
 Found 57500 records...
 Found 58000 records...
 Found 58500 records...
 Found 59000 records...
 Found 59500 records...
 Found 60000 records...
 Found 60500 records...
 Found 61000 records...
 Found 61184 records...
 Imported 61184 records. Simplifying...</code></pre>
<p>Flatten Yelp data frame
Let’s find out how the data has been imported by quickly running ‘str()’ function.</p>
<pre class="r"><code>str(yelp)</code></pre>
<pre><code>...
## &#39;data.frame&#39;:    61184 obs. of  15 variables:
##  $ business_id  : chr  &quot;vcNAWiLM4dR7D2nwwJ7nCA&quot; &quot;UsFtqoBl7naz8AVUBZMjQQ&quot; &quot;cE27W9VPgO88Qxe4ol6y_g&quot; &quot;HZdLhv6COCleJMo7nPl-RA&quot; ...
##  $ full_address : chr  &quot;4840 E Indian School Rd\nSte 101\nPhoenix, AZ 85018&quot; &quot;202 McClure St\nDravosburg, PA 15034&quot; &quot;1530 Hamilton Rd\nBethel Park, PA 15234&quot; &quot;301 S Hills Vlg\nPittsburgh, PA 15241&quot; ...
##  $ hours        :&#39;data.frame&#39;:   61184 obs. of  7 variables:
##   ..$ Tuesday  :&#39;data.frame&#39;:    61184 obs. of  2 variables:
##   .. ..$ close: chr  &quot;17:00&quot; NA NA &quot;21:00&quot; ...
##   .. ..$ open : chr  &quot;08:00&quot; NA NA &quot;10:00&quot; ...
##   ..$ Friday   :&#39;data.frame&#39;:    61184 obs. of  2 variables:
##   .. ..$ close: chr  &quot;17:00&quot; NA NA &quot;21:00&quot; ...
##   .. ..$ open : chr  &quot;08:00&quot; NA NA &quot;10:00&quot; ...
##   ..$ Monday   :&#39;data.frame&#39;:    61184 obs. of  2 variables:
##   .. ..$ close: chr  &quot;17:00&quot; NA NA &quot;21:00&quot; ...
##   .. ..$ open : chr  &quot;08:00&quot; NA NA &quot;10:00&quot; ...
##   ..$ Wednesday:&#39;data.frame&#39;:    61184 obs. of  2 variables:
##   .. ..$ close: chr  &quot;17:00&quot; NA NA &quot;21:00&quot; ...
...</code></pre>
<p>As you can see ‘hours’ variable is actually a data frame that contains 7 data frames each of which is for a weekday like ‘Tuesday’. And the weekday variables themselves are data frames and each contains two ‘character’ variables of ‘open’ and ‘close’.</p>
<p>This is reflecting the original JSON data structure, but it is a bit confusing for analyzing data in R. We can use ‘flatten()’ function from ‘jsonlite’ package to make the nested hiearchical data structure into a flatten manner by assigning each of the nested variable as its own column as much as possible.</p>
<pre class="r"><code>yelp_flat &lt;- jsonlite::flatten(yelp)
str(yelp_flat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    61184 obs. of  105 variables:
##  $ business_id                                         : chr  &quot;vcNAWiLM4dR7D2nwwJ7nCA&quot; &quot;UsFtqoBl7naz8AVUBZMjQQ&quot; &quot;cE27W9VPgO88Qxe4ol6y_g&quot; &quot;HZdLhv6COCleJMo7nPl-RA&quot; ...
##  $ full_address                                        : chr  &quot;4840 E Indian School Rd\nSte 101\nPhoenix, AZ 85018&quot; &quot;202 McClure St\nDravosburg, PA 15034&quot; &quot;1530 Hamilton Rd\nBethel Park, PA 15234&quot; &quot;301 S Hills Vlg\nPittsburgh, PA 15241&quot; ...
##  $ open                                                : logi  TRUE TRUE FALSE TRUE TRUE TRUE ...
##  $ categories                                          :List of 61184
##   ..$ : chr  &quot;Doctors&quot; &quot;Health &amp; Medical&quot;
##   ..$ : chr &quot;Nightlife&quot;
##   ..$ : chr  &quot;Active Life&quot; &quot;Mini Golf&quot; &quot;Golf&quot;
##   ..$ : chr  &quot;Shopping&quot; &quot;Home Services&quot; &quot;Internet Service Providers&quot; &quot;Mobile Phones&quot; ...
##   ..$ : chr  &quot;Bars&quot; &quot;American (New)&quot; &quot;Nightlife&quot; &quot;Lounges&quot; ...
...</code></pre>
<p>Now the data structure looks a lot easier to grasp and even the data looks easier to see.</p>
<p>Before printing out the data I’m going to use ‘as_data_frame()’ function from the new package called ‘tibble’, which was released just last week from Hadley Wickham and the team to make it easier to see the data frame data in R console UI.</p>
<p>We can use ‘as_data_frame()’ function to convert our data frame to be ‘tbl_df’, which is an extended version of the data frame. Once it’s in ‘tbl_df’ type, it automatically shows only the first 10 variables in the console output by simply typing the data frame name so you don’t need to call ‘head()’ function separately. Also, it shows a data type for each variable in the output.</p>
<pre class="r"><code>library(tibble)
yelp_tbl &lt;- as_data_frame(yelp_flat)</code></pre>
<div class="alert alert-warning">
<p><strong>Warning</strong> <code>as_data_frame()</code> is deprecated, use <code>as_tibble()</code> (but mind the new semantics).</p>
<p>This warning is displayed once per session.</p>
</div>
<pre class="r"><code>yelp_tbl</code></pre>
<pre><code>## # A tibble: 61,184 x 105
##    business_id full_address open  categories city  review_count name 
##    &lt;chr&gt;       &lt;chr&gt;        &lt;lgl&gt; &lt;list&gt;     &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;
##  1 vcNAWiLM4d… &quot;4840 E Ind… TRUE  &lt;chr [2]&gt;  Phoe…            9 Eric…
##  2 UsFtqoBl7n… &quot;202 McClur… TRUE  &lt;chr [1]&gt;  Drav…            4 Clan…
##  3 cE27W9VPgO… &quot;1530 Hamil… FALSE &lt;chr [3]&gt;  Beth…            5 Cool…
##  4 HZdLhv6COC… &quot;301 S Hill… TRUE  &lt;chr [6]&gt;  Pitt…            3 Veri…
##  5 mVHrayjG3u… &quot;414 Hawkin… TRUE  &lt;chr [5]&gt;  Brad…           11 Emil…
##  6 KayYbHCt-R… &quot;141 Hawtho… TRUE  &lt;chr [4]&gt;  Carn…           15 Alex…
##  7 b12U9TFESS… &quot;718 Hope H… TRUE  &lt;chr [2]&gt;  Carn…            5 Flyn…
##  8 Sktj1eHQFu… &quot;920 Forsyt… TRUE  &lt;chr [2]&gt;  Carn…            4 Fors…
##  9 3ZVKmuK2l7… &quot;8 Logan St… TRUE  &lt;chr [2]&gt;  Carn…            3 Quak…
## 10 wJr6kSA5dc… &quot;2100 Washi… TRUE  &lt;chr [4]&gt;  Carn…            8 King…
## # … with 61,174 more rows, and 98 more variables: neighborhoods &lt;list&gt;,
## #   longitude &lt;dbl&gt;, state &lt;chr&gt;, stars &lt;dbl&gt;, latitude &lt;dbl&gt;, type &lt;chr&gt;,
## #   hours.Tuesday.close &lt;chr&gt;, hours.Tuesday.open &lt;chr&gt;,
## #   hours.Friday.close &lt;chr&gt;, hours.Friday.open &lt;chr&gt;,
## #   hours.Monday.close &lt;chr&gt;, hours.Monday.open &lt;chr&gt;,
## #   hours.Wednesday.close &lt;chr&gt;, hours.Wednesday.open &lt;chr&gt;,
## #   hours.Thursday.close &lt;chr&gt;, hours.Thursday.open &lt;chr&gt;,
## #   hours.Sunday.close &lt;chr&gt;, hours.Sunday.open &lt;chr&gt;,
## #   hours.Saturday.close &lt;chr&gt;, hours.Saturday.open &lt;chr&gt;, `attributes.By
## #   Appointment Only` &lt;lgl&gt;, `attributes.Happy Hour` &lt;lgl&gt;,
## #   `attributes.Accepts Credit Cards` &lt;list&gt;, `attributes.Good For
## #   Groups` &lt;lgl&gt;, `attributes.Outdoor Seating` &lt;lgl&gt;, `attributes.Price
## #   Range` &lt;int&gt;, `attributes.Good for Kids` &lt;lgl&gt;,
## #   attributes.Alcohol &lt;chr&gt;, `attributes.Noise Level` &lt;chr&gt;,
## #   `attributes.Has TV` &lt;lgl&gt;, attributes.Attire &lt;chr&gt;, `attributes.Good
## #   For Dancing` &lt;lgl&gt;, attributes.Delivery &lt;lgl&gt;, `attributes.Coat
## #   Check` &lt;lgl&gt;, attributes.Smoking &lt;chr&gt;, `attributes.Take-out` &lt;lgl&gt;,
## #   `attributes.Takes Reservations` &lt;lgl&gt;, `attributes.Waiter
## #   Service` &lt;lgl&gt;, `attributes.Wi-Fi` &lt;chr&gt;, attributes.Caters &lt;lgl&gt;,
## #   `attributes.Drive-Thru` &lt;lgl&gt;, `attributes.Wheelchair
## #   Accessible` &lt;lgl&gt;, attributes.BYOB &lt;lgl&gt;, attributes.Corkage &lt;lgl&gt;,
## #   `attributes.BYOB/Corkage` &lt;chr&gt;, `attributes.Order at Counter` &lt;lgl&gt;,
## #   `attributes.Good For Kids` &lt;lgl&gt;, `attributes.Dogs Allowed` &lt;lgl&gt;,
## #   `attributes.Open 24 Hours` &lt;lgl&gt;, `attributes.Accepts
## #   Insurance` &lt;lgl&gt;, `attributes.Ages Allowed` &lt;chr&gt;,
## #   attributes.Ambience.romantic &lt;lgl&gt;,
## #   attributes.Ambience.intimate &lt;lgl&gt;, attributes.Ambience.classy &lt;lgl&gt;,
## #   attributes.Ambience.hipster &lt;lgl&gt;, attributes.Ambience.divey &lt;lgl&gt;,
## #   attributes.Ambience.touristy &lt;lgl&gt;, attributes.Ambience.trendy &lt;lgl&gt;,
## #   attributes.Ambience.upscale &lt;lgl&gt;, attributes.Ambience.casual &lt;lgl&gt;,
## #   `attributes.Good For.dessert` &lt;lgl&gt;, `attributes.Good
## #   For.latenight` &lt;lgl&gt;, `attributes.Good For.lunch` &lt;lgl&gt;,
## #   `attributes.Good For.dinner` &lt;lgl&gt;, `attributes.Good
## #   For.breakfast` &lt;lgl&gt;, `attributes.Good For.brunch` &lt;lgl&gt;,
## #   attributes.Parking.garage &lt;lgl&gt;, attributes.Parking.street &lt;lgl&gt;,
## #   attributes.Parking.validated &lt;lgl&gt;, attributes.Parking.lot &lt;lgl&gt;,
## #   attributes.Parking.valet &lt;lgl&gt;, attributes.Music.dj &lt;lgl&gt;,
## #   attributes.Music.background_music &lt;lgl&gt;,
## #   attributes.Music.karaoke &lt;lgl&gt;, attributes.Music.live &lt;lgl&gt;,
## #   attributes.Music.video &lt;lgl&gt;, attributes.Music.jukebox &lt;lgl&gt;,
## #   attributes.Music.playlist &lt;lgl&gt;, `attributes.Hair Types Specialized
## #   In.coloring` &lt;lgl&gt;, `attributes.Hair Types Specialized
## #   In.africanamerican` &lt;lgl&gt;, `attributes.Hair Types Specialized
## #   In.curly` &lt;lgl&gt;, `attributes.Hair Types Specialized In.perms` &lt;lgl&gt;,
## #   `attributes.Hair Types Specialized In.kids` &lt;lgl&gt;, `attributes.Hair
## #   Types Specialized In.extensions` &lt;lgl&gt;, `attributes.Hair Types
## #   Specialized In.asian` &lt;lgl&gt;, `attributes.Hair Types Specialized
## #   In.straightperms` &lt;lgl&gt;, `attributes.Payment Types.amex` &lt;lgl&gt;,
## #   `attributes.Payment Types.cash_only` &lt;lgl&gt;, `attributes.Payment
## #   Types.mastercard` &lt;lgl&gt;, `attributes.Payment Types.visa` &lt;lgl&gt;,
## #   `attributes.Payment Types.discover` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.dairy-free` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.gluten-free` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.vegan` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.kosher` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.halal` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.soy-free` &lt;lgl&gt;, `attributes.Dietary
## #   Restrictions.vegetarian` &lt;lgl&gt;</code></pre>
<pre class="r"><code>yelp_tbl2&lt;-yelp_tbl %&gt;% mutate(categories = as.character(categories)) %&gt;% select(categories)</code></pre>
<p>Drop now when you look at the data again, looks there are bunch of variables whose name starts with either ‘hours’ or ‘attributes’.</p>
<pre class="r"><code>yelp_tbl %&gt;% 
 select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;))</code></pre>
<pre><code>## # A tibble: 61,184 x 13
##    business_id full_address open  categories city  review_count name 
##    &lt;chr&gt;       &lt;chr&gt;        &lt;lgl&gt; &lt;list&gt;     &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;
##  1 vcNAWiLM4d… &quot;4840 E Ind… TRUE  &lt;chr [2]&gt;  Phoe…            9 Eric…
##  2 UsFtqoBl7n… &quot;202 McClur… TRUE  &lt;chr [1]&gt;  Drav…            4 Clan…
##  3 cE27W9VPgO… &quot;1530 Hamil… FALSE &lt;chr [3]&gt;  Beth…            5 Cool…
##  4 HZdLhv6COC… &quot;301 S Hill… TRUE  &lt;chr [6]&gt;  Pitt…            3 Veri…
##  5 mVHrayjG3u… &quot;414 Hawkin… TRUE  &lt;chr [5]&gt;  Brad…           11 Emil…
##  6 KayYbHCt-R… &quot;141 Hawtho… TRUE  &lt;chr [4]&gt;  Carn…           15 Alex…
##  7 b12U9TFESS… &quot;718 Hope H… TRUE  &lt;chr [2]&gt;  Carn…            5 Flyn…
##  8 Sktj1eHQFu… &quot;920 Forsyt… TRUE  &lt;chr [2]&gt;  Carn…            4 Fors…
##  9 3ZVKmuK2l7… &quot;8 Logan St… TRUE  &lt;chr [2]&gt;  Carn…            3 Quak…
## 10 wJr6kSA5dc… &quot;2100 Washi… TRUE  &lt;chr [4]&gt;  Carn…            8 King…
## # … with 61,174 more rows, and 6 more variables: neighborhoods &lt;list&gt;,
## #   longitude &lt;dbl&gt;, state &lt;chr&gt;, stars &lt;dbl&gt;, latitude &lt;dbl&gt;, type &lt;chr&gt;</code></pre>
</div>
<div id="count-how-restaurants" class="section level1">
<h1>Count how restaurants</h1>
<p>Now, let’s find out how many ‘Restaurant’ business in the data. We can use ‘str_detect()’ function from ‘stringr’ package to find the businesses whose ‘categories’ variable values contain ‘Restaurant’ text. If you want to know more detail about this function check out this post.</p>
<pre class="r"><code>library(stringr)
yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;))</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 21,892 x 13
##    business_id full_address open  categories city  review_count name 
##    &lt;chr&gt;       &lt;chr&gt;        &lt;lgl&gt; &lt;list&gt;     &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;
##  1 mVHrayjG3u… &quot;414 Hawkin… TRUE  &lt;chr [5]&gt;  Brad…           11 Emil…
##  2 KayYbHCt-R… &quot;141 Hawtho… TRUE  &lt;chr [4]&gt;  Carn…           15 Alex…
##  3 wJr6kSA5dc… &quot;2100 Washi… TRUE  &lt;chr [4]&gt;  Carn…            8 King…
##  4 fNGIbpazjT… &quot;1201 Washi… TRUE  &lt;chr [5]&gt;  Carn…            5 Rock…
##  5 b9WZJp5L1R… &quot;1073 Washi… TRUE  &lt;chr [2]&gt;  Carn…           38 Gab …
##  6 zaXDakTd3R… &quot;202 3rd Av… TRUE  &lt;chr [2]&gt;  Carn…            5 Barb…
##  7 WETE_Lykpc… &quot;215 E Main… FALSE &lt;chr [5]&gt;  Carn…            6 Padd…
##  8 rv7CY8G_Xi… &quot;Raceway Pl… TRUE  &lt;chr [1]&gt;  Carn…            3 Long…
##  9 SQ0j7bgSTa… &quot;214 E Main… TRUE  &lt;chr [2]&gt;  Carn…            8 Don …
## 10 wqu7ILomIO… &quot;2180 Green… TRUE  &lt;chr [3]&gt;  Pitt…            7 Denn…
## # … with 21,882 more rows, and 6 more variables: neighborhoods &lt;list&gt;,
## #   longitude &lt;dbl&gt;, state &lt;chr&gt;, stars &lt;dbl&gt;, latitude &lt;dbl&gt;, type &lt;chr&gt;</code></pre>
<p>The cool thing about this function is that even when we have a ‘list’ data type variable it can go inside the list values and do the text matching. Pretty awesome.</p>
<p>Now, number of the rows is 21,892, as opposed to the original of 61,184 rows. That means there are 21,892 ‘Restaurant’ related businesses in this data out of 61,184 businesses. To confirm if this is really the case, let’s look at the categories column with ‘as.character()’ function again.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 mutate(categories = as.character(categories)) %&gt;% select(categories)</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 21,892 x 1
##    categories                                                              
##    &lt;chr&gt;                                                                   
##  1 &quot;c(\&quot;Bars\&quot;, \&quot;American (New)\&quot;, \&quot;Nightlife\&quot;, \&quot;Lounges\&quot;, \&quot;Restaura…
##  2 &quot;c(\&quot;Bars\&quot;, \&quot;American (Traditional)\&quot;, \&quot;Nightlife\&quot;, \&quot;Restaurants\&quot;…
##  3 &quot;c(\&quot;Burgers\&quot;, \&quot;Breakfast &amp; Brunch\&quot;, \&quot;American (Traditional)\&quot;, \&quot;R…
##  4 &quot;c(\&quot;Bars\&quot;, \&quot;American (Traditional)\&quot;, \&quot;Nightlife\&quot;, \&quot;Lounges\&quot;, \&quot;…
##  5 &quot;c(\&quot;Breakfast &amp; Brunch\&quot;, \&quot;Restaurants\&quot;)&quot;                            
##  6 &quot;c(\&quot;Cafes\&quot;, \&quot;Restaurants\&quot;)&quot;                                         
##  7 &quot;c(\&quot;Pubs\&quot;, \&quot;Irish\&quot;, \&quot;Nightlife\&quot;, \&quot;Bars\&quot;, \&quot;Restaurants\&quot;)&quot;      
##  8 Restaurants                                                             
##  9 &quot;c(\&quot;Chinese\&quot;, \&quot;Restaurants\&quot;)&quot;                                       
## 10 &quot;c(\&quot;Breakfast &amp; Brunch\&quot;, \&quot;American (Traditional)\&quot;, \&quot;Restaurants\&quot;)&quot;
## # … with 21,882 more rows</code></pre>
<p>Looks all the rows (well, all the first 10 rows anyway) look like they have “Restaurants’ as one of the categories.</p>
<p>And this is interesting because people on Yelp are tagging different genres for each “Restaurant” business. For example, some restaurants could be considered as “Bars”, “American (New)”, “Pub”, etc. So one of the interesting question would be, “what type of the restaurants are more common in this data set?”</p>
<p>The easiest way to answer this question is to break out this ‘categories’ list data type variable and assign each value inside the list into each row. So essentially we’ll have a variable called ‘categories’ and this will have just one category value for each row. This means, some businesses might be repeated across rows many times, but that’s ok because our concern for now is to count each restaurant category type.</p>
</div>
<div id="unnest-a-list-variable" class="section level1">
<h1>Unnest a list variable</h1>
<p>To break out ‘categories’ variable and create one row for each value, we can use ‘unnest()’ function from tidyr package, which is another great package from ‘Hadleyverse’ to help making raw data into a ‘tidy’ format.</p>
<p>hadley/tidyr</p>
<p>tidyr - Easily tidy data with spread and gather functions.
github.com<br />
I will talk about more on ‘tidy’ format with ‘tidyr’ package in a separate post, but for now I am going to simply use ‘unnest()’ function to “unnest” the ‘categories’ variable like below.</p>
<pre class="r"><code>library(tidyr)
yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 select(name, categories)</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 63,909 x 2
##    name                    categories            
##    &lt;chr&gt;                   &lt;chr&gt;                 
##  1 Emil&#39;s Lounge           Bars                  
##  2 Emil&#39;s Lounge           American (New)        
##  3 Emil&#39;s Lounge           Nightlife             
##  4 Emil&#39;s Lounge           Lounges               
##  5 Emil&#39;s Lounge           Restaurants           
##  6 Alexion&#39;s Bar &amp; Grill   Bars                  
##  7 Alexion&#39;s Bar &amp; Grill   American (Traditional)
##  8 Alexion&#39;s Bar &amp; Grill   Nightlife             
##  9 Alexion&#39;s Bar &amp; Grill   Restaurants           
## 10 Kings Family Restaurant Burgers               
## # … with 63,899 more rows</code></pre>
<p>As you can see, ‘Emil’s Lounge’ is now repeated 5 times, for example. This is because it has those 5 different categories assigned to this business. This will allow us to do a quick summarization with ‘count()’ function like below.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 select(name, categories) %&gt;%
 count(categories)</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 284 x 2
##    categories                 n
##    &lt;chr&gt;                  &lt;int&gt;
##  1 Active Life               41
##  2 Adult Entertainment        2
##  3 Afghan                    13
##  4 African                   30
##  5 Airports                   1
##  6 American (New)          1494
##  7 American (Traditional)  2113
##  8 Amusement Parks            2
##  9 Apartments                 1
## 10 Appliances                 1
## # … with 274 more rows</code></pre>
<p>And if you want to see the top categories you can simply use ‘arrange()’ function to sort.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 select(name, categories) %&gt;%
 count(categories) %&gt;%
 arrange(desc(n))</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 284 x 2
##    categories                 n
##    &lt;chr&gt;                  &lt;int&gt;
##  1 Restaurants            21892
##  2 Fast Food               2383
##  3 Pizza                   2223
##  4 Mexican                 2208
##  5 American (Traditional)  2113
##  6 Nightlife               2045
##  7 Sandwiches              1981
##  8 Bars                    1934
##  9 Food                    1807
## 10 Italian                 1633
## # … with 274 more rows</code></pre>
<p>Let’s get rid of the rows with ‘Restaurants’ category because we know every single rows in this data set has something to do with ‘Restaurant’ now.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 filter(categories != &quot;Restaurants&quot;) %&gt;%
 count(categories) %&gt;%
 arrange(desc(n))</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 283 x 2
##    categories                 n
##    &lt;chr&gt;                  &lt;int&gt;
##  1 Fast Food               2383
##  2 Pizza                   2223
##  3 Mexican                 2208
##  4 American (Traditional)  2113
##  5 Nightlife               2045
##  6 Sandwiches              1981
##  7 Bars                    1934
##  8 Food                    1807
##  9 Italian                 1633
## 10 Chinese                 1496
## # … with 273 more rows</code></pre>
<p>When you run the above command you will get something like below. You can see ‘Fast Food’ is the number one, and ‘Pizza’ and ‘Mexican’ come after.</p>
<p>What are the most common restaurant types per state / province?
In this data set, there is a variable called ‘state’ that contains state names or province names of US and some European countries. So, what if we want to know what restaurant categories are more frequently showing up for each state ?</p>
<p>We can simply add ‘state’ variable into ‘count()’ function like below.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 filter(categories != &quot;Restaurants&quot;) %&gt;%
 count(state, categories) %&gt;%
 arrange(desc(n))</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 1,483 x 3
##    state categories                 n
##    &lt;chr&gt; &lt;chr&gt;                  &lt;int&gt;
##  1 AZ    Mexican                 1197
##  2 AZ    Fast Food               1035
##  3 AZ    Pizza                    944
##  4 AZ    American (Traditional)   924
##  5 AZ    Sandwiches               834
##  6 AZ    Nightlife                725
##  7 NV    Fast Food                695
##  8 AZ    Bars                     686
##  9 AZ    American (New)           668
## 10 AZ    Burgers                  648
## # … with 1,473 more rows</code></pre>
<p>Now, let’s take a look at the top restaurant category for each state. We can use ‘group_by()’ function to group the data by state and use ‘top_n()’ function to keep only the top category. Both functions are from ‘dplyr’ package.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 filter(categories != &quot;Restaurants&quot;) %&gt;%
 count(state, categories) %&gt;%
 group_by(state) %&gt;%
 top_n(1, n)</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 25 x 3
## # Groups:   state [18]
##    state categories        n
##    &lt;chr&gt; &lt;chr&gt;         &lt;int&gt;
##  1 AZ    Mexican        1197
##  2 BW    Food             82
##  3 EDH   Food            189
##  4 ELN   British           3
##  5 FIF   Bars              1
##  6 FIF   Cocktail Bars     1
##  7 FIF   Delis             1
##  8 FIF   Fast Food         1
##  9 FIF   Nightlife         1
## 10 IL    Pizza            31
## # … with 15 more rows</code></pre>
<p>As you can see there are 5 entries for “FIF” province, this is because they are all tie. But the values are just ‘1’ and that’s a really small number compared to the others. So let’s filter out those small numbers from the data before the group_by and top_n steps.</p>
<pre class="r"><code>yelp_tbl %&gt;% select(-starts_with(&quot;hours&quot;), -starts_with(&quot;attribute&quot;)) %&gt;%
 filter(str_detect(categories, &quot;Restaurant&quot;)) %&gt;%
 unnest(categories) %&gt;%
 filter(categories != &quot;Restaurants&quot;) %&gt;%
 count(state, categories) %&gt;%
 filter(n &gt; 10) %&gt;%
 group_by(state) %&gt;%
 top_n(1, n)</code></pre>
<div class="alert alert-warning">
<p>Warning in stri_detect_regex(string, pattern, negate = negate, opts_regex =</p>
<p>opts(pattern)): argument is not an atomic vector; coercing</p>
</div>
<pre><code>## # A tibble: 12 x 3
## # Groups:   state [12]
##    state categories                 n
##    &lt;chr&gt; &lt;chr&gt;                  &lt;int&gt;
##  1 AZ    Mexican                 1197
##  2 BW    Food                      82
##  3 EDH   Food                     189
##  4 IL    Pizza                     31
##  5 MLN   Cafes                     11
##  6 NC    American (Traditional)   257
##  7 NV    Fast Food                695
##  8 ON    Chinese                   29
##  9 PA    Pizza                    196
## 10 QC    French                   272
## 11 SC    American (Traditional)    13
## 12 WI    Nightlife                130</code></pre>
<p>The result is a list of the top restaurant category for each of the 12 state or province.</p>
<p>This is a very simple analysis on Yelp business data. But given where we started with Yelp business data in the raw JSON format, hope this has demonstrated how quickly, incrementally, and iteratively we can get some interesting information out of such un-traditional (not tabular) data format relatively easily and quickly.</p>
<p>Notes: Adopted from <a href="https://blog.exploratory.io/working-with-json-data-in-very-simple-way-ad7ebcc0bb89" class="uri">https://blog.exploratory.io/working-with-json-data-in-very-simple-way-ad7ebcc0bb89</a></p>
</div>
